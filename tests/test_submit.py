import pytest
from aiidalab_qe.common.widgets import (
    QEAppComputationalResourcesWidget,
    PwCodeResourceSetupWidget,
)


# @pytest.mark.skip(reason="Skipping this test for now")
@pytest.mark.usefixtures("sssp")
def test_create_builder_default(
    data_regression,
    submit_app_generator,
    pw_code,
    pp_code,
):
    """ "Test the creation of the workchain builder.

    metal, non-magnetic
    """

    app = submit_app_generator(properties=["muonic"])

    configure_step = app.configure_step

    submit_step = app.submit_step

    submit_step.codes["pw_muons"].code_selection.refresh()
    submit_step.codes["pp_code"].code_selection.refresh()

    submit_step.codes["pw_muons"].value = pw_code.uuid
    submit_step.codes["pp_code"].value = pp_code.uuid

    submit_step.codes["pw_muons"].num_cpus.value = 2

    SSSP_VERSION = "1.3"
    submit_step.input_parameters["muonic"]["pseudo_choice"] = f"SSSP/{SSSP_VERSION}/PBEsol/efficiency"
    
    submit_step._create_builder()
    # since uuid is specific to each run, we remove it from the output
    ui_parameters = remove_uuid_fields(submit_step.ui_parameters)
    # regression test for the parameters generated by the app
    # this parameters are passed to the workchain
    data_regression.check(ui_parameters)
    # test if create builder successfully
    builder = submit_step._create_builder()
    # In the future, we will check the builder parameters using regresion test

    # Check that the resources are indeed different for phonon and dielectric workflows.
    assert (
        builder.muonic.findmuon.relax.base.pw.metadata.options.resources[
            "num_mpiprocs_per_machine"
        ]
        == 2
    )
    assert (
        builder.muonic.findmuon.pwscf.pw.metadata.options.resources[
            "num_mpiprocs_per_machine"
        ]
        == 2
    )
    
def remove_uuid_fields(data):
    """
    Recursively remove fields that contain UUID values from a dictionary.

    :param data: The dictionary to process.
    :return: The dictionary with UUID fields removed.
    """
    import re

    # Define a UUID pattern
    uuid_pattern = re.compile(
        r"[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}", re.I
    )

    if isinstance(data, dict):
        new_dict = {}
        for key, value in data.items():
            # If the value matches the UUID pattern, skip adding it to the new dictionary
            if isinstance(value, str) and uuid_pattern.match(value):
                continue
            # Otherwise, process the value recursively and add it to the new dictionary
            else:
                new_dict[key] = remove_uuid_fields(value)
        return new_dict
    elif isinstance(data, list):
        # Process each item in the list recursively
        return [remove_uuid_fields(item) for item in data]
    else:
        # Return the value unchanged if it's not a dictionary or list
        return data
